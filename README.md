# Diametric

Diametric is a library for building schemas, queries, and transactions for
[Datomic][] from Ruby objects.

## Usage

### Entity API

The `Entity` module is interesting, in that it is primarily made of pure functions that take their receiver (an instance of the class they are included in) and return data that you can use in Datomic. This makes it not an ORM-like thing at all, but instead a Ruby-ish data builder for Datomic. And yet, a `Diametric::Entity` is fully `ActiveModel` compliant! You can use them anywhere you would use an `ActiveRecord` model or another `ActiveModel`-compliant instance.

They do not include all `ActiveModel` modules by default, only the ones needed to establish compliance. You may want to include others yourself, such as `Validations`, `Callbacks`, or `Dirty`.

```ruby
require 'diametric'

class Person
  include Diametric::Entity

  attribute :name, String, :index => true
  attribute :email, String, :cardinality => :many
  attribute :birthday, DateTime
  attribute :iq, Integer
  attribute :website, URI
end

Person.schema
# Datomic transaction:
# [{:db/id #db/id[:db.part/db]
#   :db/ident :person/name
#   :db/valueType :db.type/string
#   :db/cardinality :db.cardinality/one
#   :db/index true
#   :db.install/_attribute :db.part/db}
#  {:db/id #db/id[:db.part/db]
#   :db/ident :person/email
#   :db/valueType :db.type/string
#   :db/cardinality :db.cardinality/many
#   :db.install/_attribute :db.part/db}
#  {:db/id #db/id[:db.part/db]
#   :db/ident :person/birthday
#   :db/valueType :db.type/instant
#   :db/cardinality :db.cardinality/one
#   :db.install/_attribute :db.part/db}
#  {:db/id #db/id[:db.part/db]
#   :db/ident :person/iq
#   :db/valueType :db.type/long
#   :db/cardinality :db.cardinality/one
#   :db.install/_attribute :db.part/db}
#  {:db/id #db/id[:db.part/db]
#   :db/ident :person/website
#   :db/valueType :db.type/uri
#   :db/cardinality :db.cardinality/one
#   :db.install/_attribute :db.part/db}]

Person.query_data(:name => "Clinton Dreisbach")
# Datomic query:
# [:find ?e ?name ?email ?birthday ?iq ?website
#  :from $ ?name
#  :where [?e :person/name ?name]
#         [?e :person/email ?email]
#         [?e :person/birthday ?birthday]
#         [?e :person/iq ?iq]
#         [?e :person/website ?website]]
# Args:
#   ["Clinton Dreisbach"]
#
# Returns as an array, [query, args].

Person.attributes
# [:dbid, :name, :email, :birthday, :iq, :website]

person = Person.new(Hash[*(Person.attributes.zip(results_from_query).flatten)])
# or
person = Person.from_query(results_from_query)

person.iq = 180
person.tx_data(:iq)
# Datomic transaction:
# [{:db/id person.dbid
#   :person/iq 180}]

person = Person.new(:name => "Peanut")
person.tx_data
# Datomic transaction:
# [{:db/id #db/id[:db.part/user]
#   :person/name "Peanut"}]
```

### Persistence API

#### JRuby

With `Diametric::Persistence::Java`, you can create objects that know how to store themselves to Datomic through the Datomic Java API.

To use the `Diametric::Persistence::Java`, you will need to use JRuby and require `diametric/persistence/java`. When you first require this file, all JAR files needed to run Datomic will be downloaded. After the first time, the JARs will not be downloaded again.

```ruby
require 'diametric'
require 'diametric/persistence/java'

class Goat
  include Diametric::Entity
  include Diametric::Persistence::Java
  
  attribute :name, String, :index => true
end

# database URI
# will create database if it does not already exist
Diametric::Persistence::Java.connect('datomic:mem://animals')

goat = Goat.new(:name => 'Beans')
goat.dbid # => nil
goat.name # => "Beans"
goat.persisted? # => false
goat.new? # => true

goat.save
goat.dbid # => new id autogenerated
goat.name # => "Beans"
goat.persisted? # => true
goat.new? # => false

goats = Goat.where(:name => "Beans")
#=> [Goat(id: 1, name: "Beans")]

goat = Goat.first(:name => "Beans")
#=> Goat(id: 1, name: "Beans")
```

#### REST

With `Diametric::Persistence::REST`, you can create objects that know how to store themselves to Datomic through the Datomic REST API. This is your only option unless you are using JRuby.

```ruby
require 'diametric'
require 'diametric/persistence/rest'

class Goat
  include Diametric::Entity
  include Diametric::Persistence::REST
  
  attribute :name, String, :index => true
end

# database url, database alias, database name
# will create database if it does not already exist
Diametric::Persistence::REST.connect('http://localhost:9000', 'test', 'animals')

goat = Goat.new(:name => 'Beans')
goat.dbid # => nil
goat.name # => "Beans"
goat.persisted? # => false
goat.new? # => true

goat.save
goat.dbid # => new id autogenerated
goat.name # => "Beans"
goat.persisted? # => true
goat.new? # => false

goats = Goat.where(:name => "Beans")
#=> [Goat(id: 1, name: "Beans")]

goat = Goat.first(:name => "Beans")
#=> Goat(id: 1, name: "Beans")
```


## Installation

Add this line to your application's Gemfile:

    gem 'diametric'

And then execute:

    $ bundle

Or install it yourself as:

    $ gem install diametric

## Contributing

1. Fork it
2. Create your feature branch (`git checkout -b my-new-feature`)
3. Commit your changes (`git commit -am 'Add some feature'`)
4. Push to the branch (`git push origin my-new-feature`)
5. Create new Pull Request

[Datomic]: http://www.datomic.com
